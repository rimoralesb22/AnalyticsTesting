{
    "collab_server" : "",
    "contents" : "##Kmeans - Zona\n\n# load Practice data frame into memory\n#   if not alredy there\n\nsource('utils.R')\n\n# install the xlsx package, if needed\n# and load it into memory\nensure.loaded(\"data.table\")\n\nZonas = read.csv(\"KmeansZona_outliers.csv\")\nzonastable <- data.frame(Zonas)\nhead(zonastable)\n\nzonastable$Valor <-gsub(\",\",\"\",zonastable$Valor)\nzonastable$Saturacion <-gsub(\",\",\"\",zonastable$Saturacion)\nzonastable$Potencial <-gsub(\",\",\"\",zonastable$Potencial)\nzonastable$Homogeneidad <-gsub(\",\",\"\",zonastable$Homogeneidad)\n\nzonastable$Valor <-as.numeric(zonastable$Valor)\nzonastable$Saturacion <-as.numeric(zonastable$Saturacion)\nzonastable$Potencial <-as.numeric(zonastable$Potencial)\nzonastable$Homogeneidad <-as.numeric(zonastable$Homogeneidad)\n\nzonas2 = scale(zonastable[3:5], center = TRUE, scale = TRUE)\nhead(zonas2)\n\n\nzonastable = cbind(zonas2,zona=zonastable$ZONA,homogeneidadReal=zonastable$Homogeneidad,valorReal=zonastable$Valor,saturacionReal=zonastable$Saturacion,potencialReal=zonastable$Potencial)\nhead(zonastable)\nzonastable <- data.frame(zonastable)\n\ncor(zonastable[1:4])\n\n#Calcular la cantidad de clusters\n#------------------------------------------------------------------------------------\n# Crea vector \"Errores\", sin datos\n# Crea variable \"K_Max\" con la cant. maxima de k a analizar\nErrores <-NULL\nK_Max   <-9\n\n#------------------------------------------------------------------------------------\n# Ejecuta kmeans con diferentes cluster, desde 1 hasta 9\n# Luego guarda el error de cada ejecucion en el vector \"Errores\"\nfor (i in 1:K_Max)\n{\n  Errores[i] <- sum(kmeans(zonastable[1:3], centers=i)$withinss)\n}\n\n#------------------------------------------------------------------------------------\n# Grafica el vector \"Errores\"\nplot(1:K_Max, Errores, type=\"b\", \n     xlab=\"Cantidad de Cluster\", \n     ylab=\"Suma de error\")\n#\n#---------------------------------------------------------------------------------\n# Creando los 3 Cluster o usando K-MEANS\n#Luego asigna grupo a cada cliente en tabla Cliente\n#ModeloKMEANS <- kmeans(Clientes[-1],3)\n#Clientes$Grupo <- ModeloKMEANS$cluster\n\n#---------------------------------------------------------------------------------\n#Graficando los puntos de dispersi?n y luego asignando a cada punto etiquetas\n#plot(Clientes$ANOSCONSULTORA,Clientes$GANANCIA,\n#     col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)\n\n#text(Clientes$ANOSCONSULTORA,Clientes$GANANCIA,\n#     labels=Clientes$CUENTA,pos=1,col=Clientes$Grupo,cex=.7)\n\n#Salvando Datos , con el id del grupo\n#write.csv(Clientes,\"C:/Users/ricmorales/Desktop/BD/ganancia.csv\")\n\n\n\n\n#--------------------------------------------------------------#\n# PASO 2: Crea vector con Algoritmos y tabla vacÃ­a para guardar Iteraciones\nAlgoritmos         <-c(\"Hartigan-Wong\",\"Lloyd\",\"Forgy\",\"MacQueen\") \nCantidadAlgoritmos <-length(Algoritmos) # guarda la cantidad de algoritmos usados\nIteraciones        <-data.frame(Intraclase=numeric(),Algoritmo=character())\n\n#-------------------------------------------------------------------------\n\n# PASO 3: Ejecuta k-means 10 veces en cada algoritmo\n# y guarda la Distancia Intracluster de cada iteracion en la tabla Iteraciones\nfor (i in 1:CantidadAlgoritmos) \n{\n  for (ii in 1:100) \n  {\n    Modelo      <- kmeans(zonastable[1:3],5, algorithm = Algoritmos[i])\n    Iteraciones <- rbind(Iteraciones,\n                         data.frame(Intraclase = Modelo$betweenss,\n                                    Algoritmo = Algoritmos[i]))\n  }\n}\n\n#-------------------------------------------------------------------------\n# PASO 4: Calcula la media de Distancia Intracluster en cada algoritmo\n#  e identificar Algoritmo Ganador \nResultados       <- tapply(Iteraciones$Intraclase,Iteraciones$Algoritmo,mean) \nResultados       <-sort(Resultados,decreasing = T)\nAlgoritmoGanador <-names(Resultados[1])\n\n#-------------------------------------------------------------------------\n# PASO 5: Ejecuta kmeans con algoritmo ganador y asigna grupo a cada cliente\nKmeansOptimizado <- kmeans(zonastable[1:3],5, algorithm = AlgoritmoGanador)\nzonastable$Grupo   <-KmeansOptimizado$cluster\n\n#-------------------------------------------------------------------------\n\n#PASO 6: Grafica segmentacion de algoritomo ganador y luego asigna etiquetas\nplot(zonastable$Homogeneidad,zonastable$Potencial,col=zonastable$Grupo,cex.axis=.7,cex.lab=.7)\ntext(zonastable$Homogeneidad,zonastable$Potencial,\n     labels=zonastable$ZONA,pos=1,col=zonastable$Grupo,cex=.7)\ntitle(main=paste(\"Algoritmo ganador:\",AlgoritmoGanador),cex.main=.9)\n\nwrite.csv(zonastable,\"C:/Users/isalopez/Desktop/kmeans-zona.csv\")\n",
    "created" : 1461338354335.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2946757986",
    "id" : "D2CD6A5C",
    "lastKnownWriteTime" : 1461346704,
    "last_content_update" : 1461346704528,
    "path" : "~/R/Pruebas Locales/AnalyticsTesting/Proyecto Avon/Kmeans - Zona.R",
    "project_path" : "Kmeans - Zona.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}