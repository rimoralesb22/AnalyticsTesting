y <- remove_outliers(zonas1)
y <- remove_outliers(zonas1[ZONA==301][,MONTO])
boxplot(y)
boxplot(zonas1[ZONA==301][,MONTO])
IQR?
)
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.1, .9), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
y <- remove_outliers(zonas1[ZONA==301][,MONTO])
par(mfrow = c(1, 2))
boxplot(y)
boxplot(zonas1[ZONA==301][,MONTO])
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
y <- remove_outliers(zonas1[ZONA==301][,MONTO])
par(mfrow = c(1, 2))
boxplot(zonas1[ZONA==301][,MONTO])
boxplot(y)
plot(zonas1[ZONA==301][,CUENTA],zonas1[ZONA==301][,MONTO])
barplot(zonas1[ZONA==301][,CUENTA],zonas1[ZONA==301][,MONTO])
zonas1[ZONA==301][,MONTO]
barplot(zonas1[ZONA==301][,Monto],zonas1[ZONA==301][,Cuenta])
barplot(zonas1[ZONA==301][,MONTO],zonas1[ZONA==301][,CUENTA])
y <- remove_outliers(zonas1[ZONA==302][,MONTO])
## png()
par(mfrow = c(1, 2))
boxplot(zonas1[ZONA==302][,MONTO])
boxplot(y)
y <- remove_outliers(zonas1[ZONA==303][,MONTO])
## png()
par(mfrow = c(1, 2))
boxplot(zonas1[ZONA==303][,MONTO])
boxplot(y)
summary(y)
summary(y,max)
table(zonas1[ZONA==303][,CUENTA],y)
y
zonas1$MONTO
y
y <- remove_outliers(zonas1[ZONA==303])
zonas1[ZONA==303][,MONTO,CUENTA]
zonas1[ZONA==301][,MONTO,CUENTA]
y <- remove_outliers(zonas1[ZONA==301][,MONTO,CUENTA])
y <- remove_outliers(zonas1[ZONA==301][,MONTO])
zonas1$SINOUT <- y
y <- remove_outliers(zonas1[ZONA==301][,MONTO])
y
zonas1[ZONA==301,SINOUT :=y]
zonas1
zonas1[ZONA==301]
zonas1[ZONA==302]
max(y)
max(na.omit(y))
summary(y)
median(na.omit(y))
median(na.omit(y))/max(na.omit(y))
zonas[,2:3]
zonas1[,2:3]
zonas1[,2:3,with = FALSE]
zonas1[,1:2,3,with = FALSE]
zonas1[,1,3,with = FALSE]
zonas1[,1,3:,with = FALSE]
zonas1[,ZONA,MONTO,with = FALSE]
zonas1[ZONA==301][,MONTO,ZONA]
zonas1[ZONA==301][,MONTO]
zonas1[,MONTO,ZONA]
zonas1[,Sum(MONTO),ZONA]
zonas1[,sum(MONTO),ZONA]
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
maximo=max(na.omit(y))
zonas2[,Mediana :=maximo,Zona:=i]
}
zonas2 <- data.frame(ZONA=as.numeric(character()))
zonas2
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
maximo=max(na.omit(y))
zonas2[,Mediana :=maximo,ZONA:=i]
}
zonas2 <-data.table(zonas2)
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
maximo=max(na.omit(y))
zonas2[,Mediana :=maximo,ZONA:=i]
}
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
maximo=max(na.omit(y))
zonas2[,Mediana :=maximo]
}
zonas1
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
source('DBConnection.r')
#Kmeans
rs <- dbSendQuery(con,"Select vz.zona,vz.cuenta,round(sum(vz.precio*vz.CANTIDAD),2) as Monto from avon.view_Zona2013_2015 vz
group by vz.zona,vz.cuenta
order by zona,monto")
Zonas <- fetch(rs)
head(Zonas)
zonas1 <-data.table(Zonas)
#zonas1[ZONA==301,Mediana :=median(zonas1[ZONA==301][,MONTO])]
##Remove outliers
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
zonas1[ZONA==i,MAXIMO :=max(na.omit(y))]
zonas1[ZONA==i,MEDIANA :=median(na.omit(y))]
}
head(zonas1)
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
zonas1[ZONA==i,MAXIMO :=median(na.omit(y))/max(na.omit(y))]
}
head(zonas1)
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
source('DBConnection.r')
#Kmeans
rs <- dbSendQuery(con,"Select vz.zona,vz.cuenta,round(sum(vz.precio*vz.CANTIDAD),2) as Monto from avon.view_Zona2013_2015 vz
group by vz.zona,vz.cuenta
order by zona,monto")
Zonas <- fetch(rs)
head(Zonas)
#Calcular Mediana
zonas1 <-data.table(Zonas)
#zonas1[ZONA==301,Mediana :=median(zonas1[ZONA==301][,MONTO])]
##Remove outliers
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
zonas1[ZONA==i,MAXIMO :=median(na.omit(y))/max(na.omit(y))]
}
head(zonas1)
# load Practice data frame into memory
#   if not alredy there
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
source('DBConnection.r')
#Kmeans
rs <- dbSendQuery(con,"Select vz.zona,vz.cuenta,round(sum(vz.precio*vz.CANTIDAD),2) as Monto from avon.view_Zona2013_2015 vz
group by vz.zona,vz.cuenta
order by zona,monto")
Zonas <- fetch(rs)
head(Zonas)
#Calcular Mediana
zonas1 <-data.table(Zonas)
#zonas1[ZONA==301,Mediana :=median(zonas1[ZONA==301][,MONTO])]
##Remove outliers
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
for(i in 301:355)
{
y <- remove_outliers(zonas1[ZONA==i][,MONTO])
zonas1[ZONA==i,PORCENTAJE :=median(na.omit(y))/max(na.omit(y))]
}
head(zonas1)
zonas1[,ZONA,max(PORCENTAJE)]
zonas1[,ZONA,PORCENTAJE]
zonas1[,ZONA,max(PORCENTAJE)]
zonas1[,ZONA,min(PORCENTAJE)]
na.omit(zonas1)
na.omit(zonas1[,ZONA,min(PORCENTAJE)])
zonas1[,ZONA,sum(MONTO)]
zonas1[,sum(MONTO),ZONA]
zonas1[,min(PORCENTAJE),ZONA]
zonas1[,por=min(PORCENTAJE),ZONA]
zonas1[,por:=min(PORCENTAJE),ZONA]
zonas1
write.csv(zonas1[,min(PORCENTAJE),ZONA],"C:/Users/ricmorales/Desktop/BD/Mediana.csv")
##Kmeans - Zona
# load Practice data frame into memory
#   if not alredy there
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
dat = read.csv("KmeansZona.csv", header = TRUE)
summary(dat)
##Kmeans - Zona
# load Practice data frame into memory
#   if not alredy there
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
Zonas = read.csv("KmeansZona.csv", header = TRUE)
#Calcular la cantidad de clusters
#------------------------------------------------------------------------------------
# Crea vector "Errores", sin datos
# Crea variable "K_Max" con la cant. maxima de k a analizar
Errores <-NULL
K_Max   <-9
#------------------------------------------------------------------------------------
# Ejecuta kmeans con diferentes cluster, desde 1 hasta 9
# Luego guarda el error de cada ejecucion en el vector "Errores"
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Zonas[-1], centers=i)$withinss)
}
#------------------------------------------------------------------------------------
# Grafica el vector "Errores"
plot(1:K_Max, Errores, type="b",
xlab="Cantidad de Cluster",
ylab="Suma de error")
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("data.table")
Zonas = read.csv("KmeansZona.csv", header = TRUE)
zonastable <- data.table(Zonas)
zonastable
Errores <-NULL
K_Max   <-9
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(zonastable[-1], centers=i)$withinss)
}
summary(zonastable)
zonastable
Zonas = read.csv("KmeansZona.csv")
zonastable <- data.table(Zonas)
zonastable
typeof(zonatable)
typeof(zonastable)
data.tables()
zonastable[-1]
Zonas = read.csv("KmeansZona.csv")
zonastable <- data.frame(Zonas)
gsub
zonastable <- data.table(Zonas)
zonastable[ZONA=301]
zonastable[ZONA==301]
zonastable[,Valor]
gsub(",","",zonastable[,Valor])
zonastable[,VALOR :=gsub(",","",zonastable[,Valor])]
zonastable
zonastable[,Valor :=gsub(",","",zonastable[,Valor])]
zonastable
Errores <-NULL
K_Max   <-9
#------------------------------------------------------------------------------------
# Ejecuta kmeans con diferentes cluster, desde 1 hasta 9
# Luego guarda el error de cada ejecucion en el vector "Errores"
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(zonastable[-1], centers=i)$withinss)
}
Clientes = read.csv("ganancia_optimizado_6Clusters.csv")
head(Clientes)
Clientes$Grupo <- NULL
head(Clientes)
Errores <-NULL
K_Max   <-9
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[-1], centers=i)$withinss)
}
plot(1:K_Max, Errores, type="b",
xlab="Cantidad de Cluster",
ylab="Suma de error")
Clientes[2:3]
head(Clientes[2:3])
head(Clientes[2:4])
head(Clientes[1:4])
head(Clientes[3:6])
head(Clientes[3:5])
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[3:5], centers=i)$withinss)
}
plot(1:K_Max, Errores, type="b",
xlab="Cantidad de Cluster",
ylab="Suma de error")
Algoritmos         <-c("Hartigan-Wong","Lloyd","Forgy","MacQueen")
CantidadAlgoritmos <-length(Algoritmos) # guarda la cantidad de algoritmos usados
Iteraciones        <-data.frame(Intraclase=numeric(),Algoritmo=character())
for (i in 1:CantidadAlgoritmos)
{
for (ii in 1:10)
{
Modelo      <- kmeans(Clientes[3:5],6, algorithm = Algoritmos[i])
Iteraciones <- rbind(Iteraciones,
data.frame(Intraclase = Modelo$betweenss,
Algoritmo = Algoritmos[i]))
}
}
warnings()
for (i in 1:CantidadAlgoritmos)
{
for (ii in 1:100)
{
Modelo      <- kmeans(Clientes[3:5],6, algorithm = Algoritmos[i])
Iteraciones <- rbind(Iteraciones,
data.frame(Intraclase = Modelo$betweenss,
Algoritmo = Algoritmos[i]))
}
}
warnings()
Resultados       <- tapply(Iteraciones$Intraclase,Iteraciones$Algoritmo,mean)
Resultados       <-sort(Resultados,decreasing = T)
AlgoritmoGanador <-names(Resultados[1])
KmeansOptimizado <- kmeans(Clientes[3:5],6, algorithm = AlgoritmoGanador)
Clientes$Grupo   <-KmeansOptimizado$cluster
plot(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
text(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,
labels=Clientes$CUENTA,pos=1,col=Clientes$Grupo,cex=.7)
title(main=paste("Algoritmo ganador:",AlgoritmoGanador),cex.main=.9)
write.csv(Clientes,"C:/Users/ricmorales/Desktop/BD/ganancia_optimizado_6Clusters.csv")
y <- remove_outliers(Clientes[3:5])
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
y <- remove_outliers(Clientes[3:5])
Clientes[3:5]
help(IQR)
help(na.rm)
y <- remove_outliers(Clientes[3:4])
Clientes[5]
head(Clientes[5])
y <- remove_outliers(Clientes[5])
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
y <- remove_outliers(Clientes[5])
y <- remove_outliers(Clientes[4])
Clientes[4]
#K-means sample rows
source('DBConnection.r')
source('utils.R')
# install the xlsx package, if needed
# and load it into memory
ensure.loaded("dplyr")
rs <- dbSendQuery(con,"select vf.cuenta,sum(vf.precio_folleto1) AS Ganacia,
avon.sku_CampanaTot(AVON.sku_CampanaMax(vf.cuenta))-avon.sku_campanatot(avon.sku_CampanaMin(vf.cuenta))+1 as TotalCampanas,
Round(avon.sku_CuentaCampana(vf.cuenta)/(avon.sku_CampanaTot(AVON.sku_CampanaMax(vf.cuenta))-avon.sku_campanatot(avon.sku_CampanaMin(vf.cuenta))+1),2) as Participacion
from avon.view_Factura2013_2015_3 vf
group by vf.cuenta")
Clientes <- fetch(rs)
#Clientes = read.csv("ganancia_optimizado_6Clusters.csv")
#Clientes$Grupo <- NULL
head(Clientes[3:5])
Clientes
sample_n(Clientes, 1000)
Clientes <- sample_n(Clientes, 1000)
Errores <-NULL
K_Max   <-9
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[3:5], centers=i)$withinss)
}
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[-1], centers=i)$withinss)
}
clientes[-1]
Clientes[-1]
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[2:4], centers=i)$withinss)
}
plot(1:K_Max, Errores, type="b",
xlab="Cantidad de Cluster",
ylab="Suma de error")
Clientes[2:4]
head(Clientes[2:4])
head(Clientes[3:4])
head(Clientes[2:4])
Algoritmos         <-c("Hartigan-Wong","Lloyd","Forgy","MacQueen")
CantidadAlgoritmos <-length(Algoritmos) # guarda la cantidad de algoritmos usados
Iteraciones        <-data.frame(Intraclase=numeric(),Algoritmo=character())
for (i in 1:CantidadAlgoritmos)
{
for (ii in 1:100)
{
Modelo      <- kmeans(Clientes[2:4],4, algorithm = Algoritmos[i])
Iteraciones <- rbind(Iteraciones,
data.frame(Intraclase = Modelo$betweenss,
Algoritmo = Algoritmos[i]))
}
}
Resultados       <- tapply(Iteraciones$Intraclase,Iteraciones$Algoritmo,mean)
Resultados       <-sort(Resultados,decreasing = T)
AlgoritmoGanador <-names(Resultados[1])
KmeansOptimizado <- kmeans(Clientes[2:4],4, algorithm = AlgoritmoGanador)
Clientes$Grupo   <-KmeansOptimizado$cluster
plot(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
text(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,
labels=Clientes$CUENTA,pos=1,col=Clientes$Grupo,cex=.7)
title(main=paste("Algoritmo ganador:",AlgoritmoGanador),cex.main=.9)
write.csv(Clientes,"C:/Users/ricmorales/Desktop/BD/ganancia_optimizado_6Clusters_sample.csv")
ClientesTot = read.csv("Valor_clientes.csv")
head(ClientesTot)
Clientes <- sample_n(Clientes, 1000)
Errores <-NULL
K_Max   <-9
#------------------------------------------------------------------------------------
# Ejecuta kmeans con diferentes cluster, desde 1 hasta 9
# Luego guarda el error de cada ejecucion en el vector "Errores"
for (i in 1:K_Max)
{
Errores[i] <- sum(kmeans(Clientes[2:4], centers=i)$withinss)
}
#------------------------------------------------------------------------------------
# Grafica el vector "Errores"
plot(1:K_Max, Errores, type="b",
xlab="Cantidad de Cluster",
ylab="Suma de error")
#
#---------------------------------------------------------------------------------
# Creando los 3 Cluster o usando K-MEANS
#Luego asigna grupo a cada cliente en tabla Cliente
#ModeloKMEANS <- kmeans(Clientes[-1],3)
#Clientes$Grupo <- ModeloKMEANS$cluster
#---------------------------------------------------------------------------------
#Graficando los puntos de dispersi?n y luego asignando a cada punto etiquetas
#plot(Clientes$ANOSCONSULTORA,Clientes$GANANCIA,
#     col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
#text(Clientes$ANOSCONSULTORA,Clientes$GANANCIA,
#     labels=Clientes$CUENTA,pos=1,col=Clientes$Grupo,cex=.7)
#Salvando Datos , con el id del grupo
#write.csv(Clientes,"C:/Users/ricmorales/Desktop/BD/ganancia.csv")
#--------------------------------------------------------------#
# PASO 2: Crea vector con Algoritmos y tabla vacía para guardar Iteraciones
Algoritmos         <-c("Hartigan-Wong","Lloyd","Forgy","MacQueen")
CantidadAlgoritmos <-length(Algoritmos) # guarda la cantidad de algoritmos usados
Iteraciones        <-data.frame(Intraclase=numeric(),Algoritmo=character())
#-------------------------------------------------------------------------
# PASO 3: Ejecuta k-means 10 veces en cada algoritmo
# y guarda la Distancia Intracluster de cada iteracion en la tabla Iteraciones
for (i in 1:CantidadAlgoritmos)
{
for (ii in 1:100)
{
Modelo      <- kmeans(Clientes[2:4],4, algorithm = Algoritmos[i])
Iteraciones <- rbind(Iteraciones,
data.frame(Intraclase = Modelo$betweenss,
Algoritmo = Algoritmos[i]))
}
}
#-------------------------------------------------------------------------
# PASO 4: Calcula la media de Distancia Intracluster en cada algoritmo
#  e identificar Algoritmo Ganador
Resultados       <- tapply(Iteraciones$Intraclase,Iteraciones$Algoritmo,mean)
Resultados       <-sort(Resultados,decreasing = T)
AlgoritmoGanador <-names(Resultados[1])
#-------------------------------------------------------------------------
# PASO 5: Ejecuta kmeans con algoritmo ganador y asigna grupo a cada cliente
KmeansOptimizado <- kmeans(Clientes[2:4],4, algorithm = AlgoritmoGanador)
Clientes$Grupo   <-KmeansOptimizado$cluster
plot(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
plot(Clientes$GANACIA,Clientes$TOTALCAMPANAS,col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
plot(Clientes$TOTALCAMPANAS,Clientes$GANACIA,col=Clientes$Grupo,cex.axis=.7,cex.lab=.7)
text(Clientes$TOTALCAMPANAS,Clientes$GANANCIA,
labels=Clientes$CUENTA,pos=1,col=Clientes$Grupo,cex=.7)
title(main=paste("Algoritmo ganador:",AlgoritmoGanador),cex.main=.9)
